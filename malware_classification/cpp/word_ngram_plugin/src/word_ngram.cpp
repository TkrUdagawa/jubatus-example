#include <jubatus/core/fv_converter/word_splitter.hpp>
#include <jubatus/core/fv_converter/exception.hpp>
#include <string>
#include <vector>
#include <jubatus/util/lang/cast.h>
#include <map>
#include <iostream>

using namespace std;

bool is_space(char c) {
  return (c == ' ' || c == '\n' || c == '\r' || c == ',' || c == '.' || c == '?' || c == '!');
}

class word_ngram : public jubatus::core::fv_converter::word_splitter {
public:
  word_ngram(int n) : n_(n) {}

  void split(const std::string& string,
             std::vector<std::pair<size_t, size_t> >& ret_boundaries) const {
    vector<pair<size_t, size_t> > ws;
    bool space = true;
    size_t begin = 0;
    for (size_t i = 0; i < string.size(); ++i) {
      char c = string[i];
      if (is_space(c)) {
        if (!space)
          ws.push_back(make_pair(begin, i));
        space = true;
      } else {
        if (space) {
          begin = i;
        }
        space = false;
      }
    }
    if (!space)
      ws.push_back(make_pair(begin, string.size() - begin));

    for (size_t i = n_ - 1; i < ws.size(); ++i) {
      size_t begin = ws[i - n_ + 1].first;
      size_t len = ws[i].second - begin;
      ret_boundaries.push_back(make_pair(begin, len));
    }
  }

private:
  size_t n_;

};

int get_int(const map<string, string>& args, const string& key) {
  map<string, string>::const_iterator it = args.find(key);
  if (it == args.end())
    throw JUBATUS_EXCEPTION(jubatus::core::fv_converter::converter_exception(key + " is not found"));
  string val = it->second;
  return jubatus::util::lang::lexical_cast<int>(val);
}

extern "C" {
  word_ngram* create(const std::map<string, string>& args) {
    int n = get_int(args, "n");
    return new word_ngram(n);
  }

}
/*
int main() {
  word_ngram ng(2);
  string s = "hello this is a pen. hello!";
  vector<pair<size_t, size_t> > bs;
  ng.split(s, bs);
  cout << s << endl;
  for(size_t i = 0; i < bs.size(); ++i) {
    cout << bs[i].first << ":" << bs[i].second;
    cout << s.substr(bs[i].first, bs[i].second) << " ";
  }
  cout << endl;
    
}
*/
