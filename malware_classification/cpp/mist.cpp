#include <iostream>
#include <fstream>
#include <exception>
#include <stdexcept>
#include <sstream>
#include <string>

#include <pficommon/data/string/utility.h>

#include "mist.hpp"

using namespace std;

namespace {
const string kThread = "thread ";
const int kThreadLen = 7;
const int kThreadNumStringSize = 4;
}

// get thread num from '# process xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx thread 0001 #' like string
void get_thread_num(const string& line, size_t pos, string& thread_num)
{
  if (pos + kThreadLen + kThreadNumStringSize > line.size())
    throw runtime_error("bad_mist format");

  thread_num = line.substr(pos + kThreadLen, kThreadNumStringSize);
}



vector<pair<string, string > > load_mist(const string& path)
{
  ifstream ifs(path.c_str(), ifstream::in);

  vector<pair<string, string> > data;

  char linebuf[1024];
  string line;
  string thread_num;
  string::size_type index;

  stringstream bag;

  // get first thread num
  ifs.getline(linebuf, sizeof(linebuf));
  line = linebuf;
  if ((index = line.find(kThread)) == string::npos)
    throw runtime_error("bad_mist format");
  get_thread_num(line, index, thread_num);


  while (ifs && ifs.getline(linebuf, sizeof(linebuf))) {
    line = linebuf;
    if ((index = line.find(kThread)) != string::npos) {
      // push current bag
      data.push_back(pair<string, string>(thread_num, bag.str()));

      // clear and refresh thread num for next instruction
      bag.str(""); bag.clear(stringstream::goodbit);
      get_thread_num(line, index, thread_num);
    } else {
      // Get level 1 (category operation) from line
      // [Lv1]
      // [   Level 2     ]
      // [         Level 3             ]
      // xx xx | xxxxxxxx xxxxxxxx .. N
      string level1 = line.substr(0, 5);
      level1.erase(2,1);
      bag << level1;
      bag << " ";
    }
  }

  // push bag
  data.push_back(pair<string, string>(thread_num, bag.str()));

  return data;
}

vector<sample_type> load_csv(const string& path)
{
  vector<sample_type> data;
  ifstream ifs(path.c_str(), ifstream::in);
  char linebuf[1024];
  string line;

  // remove first line
  ifs.getline(linebuf, sizeof(linebuf));

  // format #sha1,md5,size,av-label,analsyses-date# 
  while (ifs && ifs.getline(linebuf, sizeof(linebuf))) {
    line = linebuf;
    vector<string> csv = pfi::data::string::split(line, ',');
    if (csv.size() < 5)
      throw runtime_error("unsuppoted csv");

    sample_type s = { csv[0], csv[1], csv[2], csv[3], csv[4] };
    data.push_back(s);
  }

  return data;
}


